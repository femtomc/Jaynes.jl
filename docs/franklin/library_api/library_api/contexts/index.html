<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Execution contexts · Jaynes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Jaynes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Jaynes.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../sites/">Traces, choices, and call sites</a></li><li class="is-active"><a class="tocitem" href>Execution contexts</a></li><li><a class="tocitem" href="../selection_interface/">Selection interface</a></li><li><span class="tocitem">Inference</span><ul><li><a class="tocitem" href="../../inference/is/">Importance sampling</a></li><li><a class="tocitem" href="../../inference/mh/">Metropolis-Hastings</a></li><li><a class="tocitem" href="../../inference/pf/">Particle filtering</a></li><li><a class="tocitem" href="../../inference/vi/">Automatic differentiation variational inference</a></li></ul></li><li><a class="tocitem" href="../fmi/">Foreign model interface</a></li><li><a class="tocitem" href="../diff_prog/">Differentiable programming</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Execution contexts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Execution contexts</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/femtomc/Jaynes.jl/blob/master/docs/src/library_api/contexts.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>Here is a description of the set of &quot;standard&quot; contexts which are used frequently in modeling and inference. Gradient and foreign model contexts are discussed in <a href="../diff_prog/">Differentiable programming</a> and <a href="../fmi/">Foreign model interface</a>, respectively.</p><article class="docstring"><header><a class="docstring-binding" id="Jaynes.GenerateContext" href="#Jaynes.GenerateContext"><code>Jaynes.GenerateContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct GenerateContext{T &lt;: AddressMap, K &lt;: AddressMap, P &lt;: Parameters} &lt;: ExecutionContext
     tr::T
     target::K
     weight::Float64
     score::Float64
     visited::Visitor
     params::P
end</code></pre><p><code>GenerateContext</code> is used to generate traces, as well as record and accumulate likelihood weights given observations at addressed randomness.</p><p>Inner constructors:</p><pre><code class="language-julia">GenerateContext(tr::T, target::K) where {T &lt;: AddressMap, K &lt;: AddressMap} = new{T, K}(tr, target, 0.0, Visitor(), Parameters())
GenerateContext(tr::T, target::K, params::P) where {T &lt;: AddressMap, K &lt;: AddressMap, P &lt;: Parameters} = new{T, K, P}(tr, target, 0.0, Visitor(), params)</code></pre><p>Outer constructors:</p><pre><code class="language-julia">Generate(target::AddressMap) = GenerateContext(AddressMap(), target)
Generate(target::AddressMap, params) = GenerateContext(AddressMap(), target, params)
Generate(tr::AddressMap, target::AddressMap) = GenerateContext(tr, target)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/generate.jl#L49-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.generate" href="#Jaynes.generate"><code>Jaynes.generate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ret, cl, w = generate(target::L, fn::Function, args...; params = Parameters()) where L &lt;: AddressMap
ret, cs, w = generate(target::L, fn::typeof(rand), d::Distribution{K}; params = Parameters()) where {L &lt;: AddressMap, K}
ret, v_cl, w = generate(target::L, fn::typeof(markov), call::Function, len::Int, args...; params = Parameters()) where L &lt;: AddressMap
ret, v_cl, w = generate(target::L, fn::typeof(plate), call::Function, args::Vector; params = Parameters()) where L &lt;: AddressMap
ret, v_cl, w = generate(target::L, fn::typeof(plate), d::Distribution{K}, len::Int; params = Parameters()) where {L &lt;: AddressMap, K}</code></pre><p><code>generate</code> provides an API to the <code>GenerateContext</code> execution context. You can use this function on any of the matching signatures above - it will return the return value <code>ret</code>, a <code>RecordSite</code> instance specialized to the call, and the score/weight <code>w</code> computed with respect to the constraints <code>target</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/generate.jl#L76-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.SimulateContext" href="#Jaynes.SimulateContext"><code>Jaynes.SimulateContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct SimulateContext{T &lt;: AddressMap, P &lt;: AddressMap} &lt;: ExecutionContext
    tr::T
    visited::Visitor
    params::P
    SimulateContext(params) where T &lt;: AddressMap = new{T}(AddressMap(), Visitor(), params)
end</code></pre><p><code>SimulateContext</code> is used to simulate traces without recording likelihood weights. <code>SimulateContext</code> can be instantiated with custom <code>AddressMap</code> instances, which is useful when used for gradient-based learning.</p><p>Inner constructors:</p><pre><code class="language-julia">SimulateContext(params) = new{DynamicAddressMap}(AddressMap(), Visitor(), params)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/simulate.jl#L33-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.simulate" href="#Jaynes.simulate"><code>Jaynes.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ret, cl = simulate(fn::Function, args...; params = LearnableByAddress())
ret, cl = simulate(fn::typeof(rand), d::Distribution{T}; params = LearnableByAddress()) where T
ret, v_cl = simulate(c::typeof(plate), fn::Function, args::Vector; params = LearnableByAddress()) where T
ret, v_cl = simulate(fn::typeof(plate), d::Distribution{T}, len::Int; params = LearnableByAddress()) where T
ret, v_cl = simulate(c::typeof(markov), fn::Function, len::Int, args...; params = LearnableByAddress())</code></pre><p><code>simulate</code> function provides an API to the <code>SimulateContext</code> execution context. You can use this function on any of the matching signatures above - it will return the return value <code>ret</code>, and a <code>RecordSite</code> instance specialized to the call. <code>simulate</code> is used to express unconstrained generation of a probabilistic program trace, without likelihood weight recording.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/simulate.jl#L52-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.ProposeContext" href="#Jaynes.ProposeContext"><code>Jaynes.ProposeContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ProposeContext{T &lt;: AddressMap, P &lt;: AddressMap} &lt;: ExecutionContext
    tr::T
    score::Float64
    visited::Visitor
    params::P
end</code></pre><p><code>ProposeContext</code> is used to propose traces for inference algorithms which use custom proposals. <code>ProposeContext</code> instances can be passed sets of <code>AddressMap</code> to configure the propose with parameters which have been learned by differentiable programming.</p><p>Inner constructors:</p><pre><code class="language-julia">ProposeContext(tr::T) where T &lt;: AddressMap = new{T}(tr, 0.0, AddressMap())</code></pre><p>Outer constructors:</p><pre><code class="language-julia">Propose() = ProposeContext(AddressMap())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/propose.jl#L32-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.propose" href="#Jaynes.propose"><code>Jaynes.propose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ret, g_cl, w = propose(fn::Function, args...)
ret, cs, w = propose(fn::typeof(rand), d::Distribution{K}) where K
ret, v_cl, w = propose(fn::typeof(markov), call::Function, len::Int, args...)
ret, v_cl, w = propose(fn::typeof(plate), call::Function, args::Vector)
ret, v_cl, w = propose(fn::typeof(plate), d::Distribution{K}, len::Int) where K</code></pre><p><code>propose</code> provides an API to the <code>ProposeContext</code> execution context. You can use this function on any of the matching signatures above - it will return the return value <code>ret</code>, a <code>RecordSite</code> instance specialized to the call, and the score <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/propose.jl#L58-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.ScoreContext" href="#Jaynes.ScoreContext"><code>Jaynes.ScoreContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ScoreContext{P &lt;: AddressMap} &lt;: ExecutionContext
    select::AddressMap
    weight::Float64
    params::P
end</code></pre><p>The <code>ScoreContext</code> is used to score selections according to a model function. For computation in the <code>ScoreContext</code> to execute successfully, the <code>select</code> selection must provide a choice for every address visited in the model function, and the model function must allow the context to visit every constraints expressed in <code>select</code>.</p><p>Inner constructors:</p><pre><code class="language-julia">function Score(obs::Vector{Tuple{K, P}}) where {P, K &lt;: Union{Symbol, Pair}}
    c_sel = selection(obs)
    new{EmptyAddressMap}(c_sel, 0.0, AddressMap())
end</code></pre><p>Outer constructors:</p><pre><code class="language-julia">ScoreContext(obs::K, params) where {K &lt;: AddressMap} = new(obs, 0.0, params)
Score(obs::Vector) = ScoreContext(selection(obs))
Score(obs::AddressMap) = ScoreContext(obs, AddressMap())
Score(obs::AddressMap, params) = ScoreContext(obs, params)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/score.jl#L39-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.score" href="#Jaynes.score"><code>Jaynes.score</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ret, w = score(sel::L, fn::Function, args...; params = AddressMap()) where L &lt;: AddressMap
ret, w = score(sel::L, fn::typeof(rand), d::Distribution{K}; params = AddressMap()) where {L &lt;: AddressMap, K}
ret, w = score(sel::L, fn::typeof(markov), call::Function, len::Int, args...; params = AddressMap()) where L &lt;: AddressMap
ret, w = score(sel::L, fn::typeof(plate), call::Function, args::Vector; params = AddressMap()) where L &lt;: AddressMap
ret, w = score(sel::L, fn::typeof(plate), d::Distribution{K}, len::Int; params = AddressMap()) where {L &lt;: AddressMap, K}</code></pre><p><code>score</code> provides an API to the <code>ScoreContext</code> execution context. You can use this function on any of the matching signatures above - it will return the return value <code>ret</code>, and the likelihood weight score of the user-provided selection <code>sel</code>. The selection should satisfy the following requirement:</p><ol><li>At any random choice in any branch traveled according to the constraints of <code>sel</code>, <code>sel</code> must provide a constraint for that choice.</li></ol><p>Simply put, this just means you need to provide a constraint for each <code>ChoiceSite</code> you encounter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/score.jl#L70-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.UpdateContext" href="#Jaynes.UpdateContext"><code>Jaynes.UpdateContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct UpdateContext{C &lt;: CallSite, 
                             T &lt;: AddressMap,
                             K &lt;: AddressMap, 
                             P &lt;: AddressMap, 
                             D &lt;: Diff} &lt;: ExecutionContext
    prev::C
    tr::T
    select::K
    weight::Float64
    score::Float64
    discard::DynamicAddressMap
    visited::Visitor
    params::P
    argdiffs::D
end</code></pre><p>Inner constructor:</p><pre><code class="language-julia">UpdateContext(cl::C, select::K, argdiffs::D) where {C &lt;: CallSite, K &lt;: AddressMap, D &lt;: Diff} = new{C, typeof(cl.trace), K, EmptyAddressMap, D}(cl, typeof(cl.trace)(), select, 0.0, 0.0, AddressMap(), Visitor(), AddressMap(), argdiffs)
UpdateContext(cl::C, select::K, ps::P, argdiffs::D) where {C &lt;: CallSite, K &lt;: AddressMap, P &lt;: AddressMap, D &lt;: Diff} = new{C, typeof(cl.trace), K, EmptyAddressMap, D}(cl, typeof(cl.trace)(), select, 0.0, 0.0, AddressMap(), Visitor(), ps, argdiffs)</code></pre><p><code>UpdateContext</code> is an execution context used for updating the value of random choices in an existing recorded call site. This context will perform corrective updates to the likehood weights and scores so that this operation produces the correct weights and scores for the original model program constrained with the <code>select</code> selection in the <code>UpdateContext</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/update.jl#L64-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.update" href="#Jaynes.update"><code>Jaynes.update</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ret, cl, w, retdiff, d = update(ctx::UpdateContext, cs::DynamicCallSite, args...) where D &lt;: Diff
ret, cl, w, retdiff, d = update(sel::L, cs::DynamicCallSite) where L &lt;: AddressMap
ret, cl, w, retdiff, d = update(sel::L, cs::DynamicCallSite, argdiffs::D, new_args...) where {L &lt;: AddressMap, D &lt;: Diff}
ret, v_cl, w, retdiff, d = update(sel::L, vcs::VectorizedCallSite{typeof(plate)}) where {L &lt;: AddressMap, D &lt;: Diff}
ret, v_cl, w, retdiff, d = update(sel::L, vcs::VectorizedCallSite{typeof(markov)}) where {L &lt;: AddressMap, D &lt;: Diff}
ret, v_cl, w, retdiff, d = update(sel::L, vcs::VectorizedCallSite{typeof(markov)}, d::NoChange, len::Int) where {L &lt;: AddressMap, D &lt;: Diff}
ret, v_cl, w, retdiff, d = update(sel::L, vcs::VectorizedCallSite{typeof(markov)}, len::Int) where {L &lt;: AddressMap, D &lt;: Diff}</code></pre><p><code>update</code> provides an API to the <code>UpdateContext</code> execution context. You can use this function on any of the matching signatures above - it will return the return value <code>ret</code>, the updated <code>RecordSite</code> instance <code>cl</code> or <code>v_cl</code>, the updated weight <code>w</code>, a <code>Diff</code> instance for the return value <code>retdiff</code>, and a structure which contains any changed (i.e. discarded) record sites <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/update.jl#L94-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.RegenerateContext" href="#Jaynes.RegenerateContext"><code>Jaynes.RegenerateContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct RegenerateContext{T &lt;: Trace, 
                                 L &lt;: Target,
                                 P &lt;: AddressMap} &lt;: ExecutionContext
    prev::T
    tr::T
    target::L
    weight::Float64
    score::Float64
    discard::T
    visited::Visitor
    params::P
end</code></pre><p>Inner constructors:</p><pre><code class="language-julia">function RegenerateContext(tr::T, sel::Vector{Address}) where T &lt;: Trace
    un_sel = targetion(sel)
    new{T, typeof(un_sel), EmptyAddressMap}(tr, Trace(), un_sel, 0.0, Trace(), Visitor(), AddressMap())
end
function RegenerateContext(tr::T, sel::L) where {T &lt;: Trace, L &lt;: Target}
    new{T, L, EmptyAddressMap}(tr, Trace(), sel, 0.0, Trace(), Visitor(), AddressMap())
end</code></pre><p>Outer constructors:</p><pre><code class="language-julia">Regenerate(tr::Trace, sel::Vector{Address}) = RegenerateContext(tr, sel)
Regenerate(tr::Trace, sel::Target) = RegenerateContext(tr, sel)</code></pre><p>The <code>RegenerateContext</code> is used for MCMC algorithms, to propose new choices for addresses indicated by an <code>Target</code> in the <code>target</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/regenerate.jl#L63-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jaynes.regenerate" href="#Jaynes.regenerate"><code>Jaynes.regenerate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ret, cl = regenerate(sel::L, cs::DynamicCallSite, new_args...) where L &lt;: Target
ret, cl = regenerate(sel::L, cs::DynamicCallSite) where L &lt;: Target</code></pre><p><code>regenerate</code> is an API to the <code>RegenerateContext</code> execution context. <code>regenerate</code> requires that users provide an <code>Target</code>, an original call site, and possibly a set of new arguments to be used in the regeneration step. This context internally keeps track of the bookkeeping required to increment likelihood weights, as well as prune off parts of the trace which are invalid if a regenerated choice changes the shape of the trace (e.g. control flow), and returns a new return value <code>ret</code> as well as the modified call site <code>cl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/femtomc/Jaynes.jl/blob/4244e54d337f9fb44d3d8a08a3a7fd47c5d87018/src/contexts/regenerate.jl#L102-L108">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sites/">« Traces, choices, and call sites</a><a class="docs-footer-nextpage" href="../selection_interface/">Selection interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 23 August 2020 15:17">Sunday 23 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
